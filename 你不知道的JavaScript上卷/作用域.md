# 作用域

## 第一章 作用域是什么


将变量引入到程序会引发一些问题：变量储存在哪，程序需要如何找到它们？这些问题说明需要一套设计良好的规则来存储变量，且之后可以方便找到这些变量，这套规则被称为作用域。

在哪里且怎么设置这些作用域规则呢？

### 编译原理

JavaScript是一门编译语言，但与传统编程语言不通，他不是提前编译，编译结果不能进行移植。编译过程同样经过：分词/词法分析、解析/语法分析、代码生成三个阶段，具体如下。

比起编译过程只有这三个阶段的语言的编译器，JavaScript引擎复杂得多。（比如在语法分析和代码生成阶段有特定步骤来运行性能优化）

**1. 分词/词法分析**

将由字符组成的字符串分解成有意义的代码块，这些代码块叫“词法单元”。例如：程序var a = 2;会被分解为下面这些词法单元：var、a、=、2;


**2. 解析/语法分析**

将词法单元组（数组）转换为一个由元素逐级嵌套所组成的代表程序语法的结构树(抽象语法树AST)。var a = 2;的抽象语法树中可能有一个叫AssignmentExpression的子节点，该节点有一个叫NumericLiteral（值为2）的子节点。

**3. 代码生成**


将AST转换为可执行代码。即可以将var a = 2;的AST转换为一组机器指令，用来创建一个叫a的变量(包括分配内存等）,并将一个值储存在a中。


### 理解作用域


#### 1. 引擎

从头负责整个JavaScript程序的编译及执行过程。

#### 2. 编译器

负责语法分析及代码生成。

#### 3. 作用域

负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套严格规则，确定当前执行代码对这些标识符的访问权限。

**var a = 2;发生了什么？**

编译器首先会在作用域中声明一个变量（如果之前没有声明过），接下来编译器会为引擎生成运行时所需的代码，这些代码用来处理a = 2这个赋值操作，然后在引擎运行时，引擎会在作用域中查找该变量，如果找到就执行赋值操作，否则就抛出异常。

**一些编译器术语**

- LHS。 当变量出现在赋值操作的左侧时进行LHS查询，试图找到变量容器本身从而可以对其赋值，不成功的LHS引用会导致自动隐式创建一个全局变量（非严格模式）。
- RHS。 当变量出现在赋值操作的右侧时进行RHS查询，和简单地查找某个变量的值无异，取到它的源值，不成功的RHS引用会导致抛出ReferenceError异常。

```javascript
console.log(a); // RHS
a = 2; // LHS
```


## 第二章 词法作用域

- 词法作用域就是定义在词法阶段的作用域，是由你在写代码时将变量和块作用域写在哪里决定的，因此词法分析器处理代码时会保持作用域不变。（在《JavaScript语言精粹》--精华及语法篇中有更详细介绍）


- 可以用eval和with改变作用域。（在《高性能JavaScript》--数据存取部分有详细介绍）


## 第三章 函数作用域和块级作用域

声明在一个函数内部的变量或函数会在所处的作用域中“隐藏”起来。一方面，这是有意为之的良好软件的设计原则(限制外部作用域对变量的“访问权限”)。另一方面，这样可以规避冲突，避免同名标识符之间的冲突。



### 块级作用域

**let**

ES6引入了let关键字，允许你声明一个作用域被限制在块级中的变量、语句或者表达式。


**垃圾收集**

块级作用域一个非常有用的原因和闭包及回收内存垃圾的回收机制有关。

```javascript
function process(data) {
	// 在这做点有趣的事情
}

var someReallyBigData = {};

process(someReallyBigData);

var btn = document.getElementById('my_button');

btn.addEventListener('click', function click(evt) {
	console.log('button clicked');
}，false);
```

click函数的点击回调不需要someReallyBigData变量，理论上意味着process(...)执行后，内存中大量空间的数据结构就可以被垃圾回收了，但click函数形成了一个覆盖整个作用域的闭包，JavaScript引擎有可能依然保存这个结构（看具体实现）。

块级作用域可以取消上述这种顾虑，让引擎清除地直到没必要保存someReallyBigData。

```javascript
function process(data) {
	// 在这做点有趣的事情
}

// 在这个块定义的内容完事后就可以销毁！
{
	let someReallyBigData = {};

	process(someReallyBigData);
}

var btn = document.getElementById('my_button');

btn.addEventListener('click', function click(evt) {
	console.log('button clicked');
}，false);
```

**const**

ES6引入了const，同样可以创建块作用域变量，但其值时固定的（常量），在声明时必须初始化（否则会导致SyntaxError错误），之后任何试图修改值的操作都会引起TypeError错误。

