# 数据存取

数据存储的位置关系到代码执行过程中数据检索速度，可通过改变数据的存储位置来获取最佳的读写性能。

## 管理作用域

### 作用域和标识符解析

每个JavaScript函数都表示为一个对象，确切的说是Function对象的一个实例。Function对象和其他对象一样，拥有可以编程访问的属性，和一系列不能通过代码访问而仅供JavaScript内部引擎存取的内部属性。

其中一个内部属性是[[scope]],包含了一个函数被创建的作用域中的对象的集合，这个集合被称为函数的作用域链，它决定了哪些数据能被函数访问。当一个函数创建后，它的作用域链会被创建此函数作用域中可访问的数据对象所填充。如

```javascript
function add(num1,num2) {
	var sum = num1 + num2;
	return sum;
}
```

当add()创建时，它的作用域链中插入一个全局对象，这个全局对象代表着所有在全局范围内定义的变量（包括window、navigator、document等）。

```javascript
var total = add(5, 10);
```

执行函数时会创建一个称为执行环境的内部对象，一个执行环境定义了一个函数执行时的环境，函数每次执行时对应的执行环境都是独一无二的，当函数执行完毕，执行环境就销毁。

每个执行环境都有自己的作用域链，用于解析标识符。当执行环境被创建时，它的作用域链初始化为当前运行函数的[[scope]]属性中的对象。这些值按出现在函数中的顺序被复制到执行环境的作用域中。这个过程一旦完成，一个称为“活动对象”的新对象就为执行环境创建好了。活动对象作为函数运行时的变量对象，包含了所有局部变量，命名参数，参数集合以及this，然后这个“活动对象”被推入到作用域链的最前端，当执行环境被销毁时，活动对象也随之销毁。

**标识符解析：**

在函数执行过程中，每遇到一个标识符，都会经历一次标识符解析过程以决定从哪里获取存储数据。标识符解析过程：搜索执行环境的作用域链，从头部开始（即当前运行函数的活动对象），查找同名的标识符，找到则使用，未找到则继续搜索作用域中的下一个对象，若最终仍未找到，则该标识符视为未定义,如果作用域链的不同部分有这个标识符，标识符会是遍历作用域链时最先找到的那个。**正是这个搜索过程影响了性能。**

### 标识符解析的性能

在执行环境的作用域链中，一个标识符所在的位置越深，它的读写速度也就越慢。所以，函数中读写局部变量总是最快的，读写全局变量总是最慢的。**全局变量总是存在执行环境作用域链的最末端，因此也是最远的。**


**如果某个跨作用域的值在函数中被引用一次以上，最好将它存储到局部变量上。**

### 改变作用域链

在执行时临时改变作用域链。

**1. with语句**


with通常用来避免书写重复代码，它可以给对象的所有属性创建一个变量。

```javascript
function initUI() {
	with (document) { // 避免使用！
		var bd = body,
			links = getElementByTagName('a'),
			i = 0,
			len = links.length;
		
		while (i < len) {
			update(links[i++]);
		}

		getElementById('go-btn').onclick = function() {
			start();
		};

		bd.className = 'active';
	}
}
```

使用with语句避免多次书写document，看似高效，但实际上产生一个性能问题。

当代码执行到with语句时，执行环境的作用域链临时改变了，一个新的变量对象被创建，它包含了参数指定的对象的所有属性，这个新的变量对象被推到作用域链顶端，意味着函数的所有局部变量都处于第二个作用域链对象中，访问代价更高。

结合上述代码分析：即通过把document对象传递给with语句，一个包含document对象所有属性的新的可变变量被置于作用域链顶部，这使得访问document对象的属性非常快，访问局部变量则变慢，最好避免这种做法，应通过将document赋值给一个局部变量的方式来提升性能。

(在《JavaScript语言精粹》中也提到应当避免使用with)


**2. try-catch语句中的catch子句**

当try语句块中发生错误时，执行过程会自动跳到catch子句，然后把异常对象推入一个变量对象并置于作用域的首位，在catch代码块内部，所有局部变量将会放在第二个作用域链对象中，一旦catch子句执行完毕，作用域链会返回到之前的状态。


try-catch最好只用来做错误提示，降低调试难度，不建议用来解决JavaScript错误。如果一定要这么做，需要确保catch子句对性能的影响最小化，推荐做法是将错误委托给一个函数来处理。

```javascript
try {
	methodThatMightCauseAnError();
} catch (ex){
	handleError(ex); // 委托给错误处理器函数
}
```

### 动态作用域

无论是with语句、try-catch中的catch子句，还是包含eval()的函数都被视为动态作用域。动态作用域只存在于代码执行过程中，无法通过静态分析(查看代码结构)检测出来。如：

```javascript
function execute(code) {
	eval(code);

	function subroutine() {
		return window;
	}

	var w = subroutine();

	//w 是什么？
}
```

由于使用了eval()，函数execute()看上去像动态作用域，变量w的值会随code的值改变。大部分情况w为window，但考虑到如下情况：

```javascript
	execute('var window = {};');
```

这时w等于局部变量window,而非全局对象window。

经过JavaScript引擎优化，会尝试通过分析代码确定哪些变量可在特定时候访问，这些引擎避免传统作用域链查找，以标识符索引的方式进行快速查找，当涉及动态作用域时，这种优化方式就失效了，脚本引擎必须切换回较慢的基于哈希表的标识符识别方式，更像是传统作用域链查找。

**因此，只有在确实有必要时才推荐使用动态作用域。**


### 闭包、作用域和内存

闭包是JavaScript最强大的特性之一，允许函数访问局部作用域之外的数据,不过使用闭包可能会导致性能问题。

```javascript
function assignEvents() {
	
	var id = 'xdi9592';
	
	document.getElementById('save-btn').onclick = function(event) {
		saveDocument(id);
	}
}
```

当assignEvents()函数执行时, 一个包含了变量id以及其他数据的活动对象被创建,它成为执行环境作用域中第一个对象, 而全局对象紧随其后,而当闭包被创建时, 它的[[Scope]]属性被初始化为这些对象。

通常函数的活动对象会随执行环境一同销毁，但由于闭包的[[scope]]属性包含了与执行环境作用域链相同的对象的引用，因此激活对象无法销毁。因此脚本中的闭包和非闭包相比，需要更多的内存开销。

在闭包中可能存在频繁访问跨作用域的标识符，每次访问都会带来性能损失，因此最好小心使用闭包，因为它同时关系到内存和执行速度。不过也可以通过上面提到的将跨作用域变量存储到局部变量的方式减轻性能影响。



## 对象成员

访问对象成员的速度比访问字面量或变量要慢，在某些浏览器中比访问数组元素还慢。

### 原型

对象可以有两种成员类型：实例成员、原型成员。实例成员直接存在于对象实例中，原型对象则从对象原型继承而来。实例成员直接存在于对象实例中，原型成员则从对象原型继承而来。

```javascript
var book = {
	title: 'High Performance JavaScript',
	publisher: 'Yahoo! Press'
}

alert(book.toString()); //'[object Object]'
```

这段代码中，对象book有两个实例成员：title,publisher。而方法toString()是由对象Object继承而来的原型成员。

解析对象成员的过程：先从对象实例开始，没有找到的话再继续搜索其原型对象，直至找到返回。


### 原型链

属性或方法在原型链中存在的位置越深，访问它的速度就越慢。

### 嵌套成员

由于对象成员可能包含其他成员，例如：window.location.href，每次遇到点操作符(或括号表达式[])，嵌套成员会导致JavaScript引擎搜索所有对象成员，因此，对象成员嵌套越深，读取速度就越慢，如果这些属性不是对象的实例属性，则成员解析还需要搜索原型链，会花更多时间。

### 缓存对象成员值

由于所有类似的性能问题都与对象成员有关，因此应当尽可能避免使用它们，更确切地说，只在必要时使用对象成员。通常来说，**在函数中，如果要多次读取同一个对象属性，最佳做法是将属性保存到局部变量中。**

