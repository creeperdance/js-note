# 字符串和正则表达式

## 字符串连接

**字符串合并的方法**

- the + operator
- the += operator
- array.join()
- string.concat()

### 加 (+) 和 加等(+=) 操作符

以下优化针对IE8后的浏览器

```javascript
// 以下代码会创建一个临时字符串并将'onetwo'赋值给它，再将其与str连接
str += 'one' + 'two';
 
// 以下代码用两行语句直接附加内容到str,避免了产生临时字符串
str += 'one';
str += 'two';

// 同样可以仅用一句话就达到上面的性能,下面代码等价于 str= ((str+'one')+'two'); 
str = str + 'one' + 'two';

// 若顺序改变优化会失效，浏览器会尝试为表达式左侧字符串分配更多内存，然后将后面的字符串拷贝至其末尾。
str = 'one' + str + 'two';
```


### 数组项合并

Array.prototype.join方法接收一个分隔符，将数组的所有元素按分隔符合并成一个字符串，所以传入的分隔符为空，就可以简单连接数组的所有元素。


在大多数浏览器(不考虑IE7及更早版本浏览器)中，数组项合并是最慢的字符串连接方法之一。

### String.prototype.concat

字符串原生方法concat能接收任意数量的参数，并将每一个参数附加到所调用的字符串上，参数可以为任意个字符串或整个字符串数组。

```javascript
// 附加一个字符串
str = str.concat(s1);

// 附加三个字符串
str = str.concat(s1,s2,s3);

// 传递一个数组，附加数组中的所有字符串
str = String.prototype.concat.call(str,array);
```

使用concat比使用 + 和 += 稍慢,因此推荐使用 + 和 += 。



## 正则表达式优化

草率地编写正则表达式可能是造成性能瓶颈的主要原因（在“回溯失控”一节会说明其严重性），但也有很多提高正则表达式运行效率的方法。不同的浏览器对正则表达式引擎有不同程度的内部优化，导致一个正则表达式在一个浏览器中更快，但在另一个浏览器中更慢。

### 正则表达式工作原理

**第1步. 编译**

创建了一个正则表达式后，浏览器会先验证该表达式，然后将它转换为一个原生代码程序，用于执行匹配工作。如果将正则表达式赋值给一个变量，可以避免该步骤。

**第2步. 设置起始位置**

当正则表达式进入使用状态，首先要确定目标字符串的起始搜索位置。它是字符串的起始字符，或者由正则表达式的lastIndex属性指定，当它从第4步返回到这里时(匹配状态失败)，此位置则为最后一次匹配的起始位置的下一个字符的位置。

浏览器优化正则表达引擎的办法是，通过提前决定跳过一些不必要操作，避免大量无意义工作，比如正则表达式由^开始，会判断字符串的起始位置能否匹配，不匹配则跳过。再比如匹配第三个是x的字符串，部分浏览器会先找到x,在将起始位置回退两个字符。

**第3步. 匹配每个正则表达字元**

一旦正则表达式确定起始位置，就会逐个检查文本和正则表达式模式，当一个特定字元匹配失败时，正则表达式会试着**回溯**到之前尝试匹配的位置上，然后尝试其他可能途径。

**第4步. 匹配成功或失败**

如果在字符串当前位置发现一个完全匹配，则正则表达式宣布匹配成功。如果正则表达式所有可能路径都没有匹配到，正则表达式会回退到第二部，从下一个字符重新尝试，当每个字符都经历过这个过程仍未找到则正则表达式宣布彻底匹配失败。


### 理解回溯

在上述步骤中的第3步中提到匹配过程中的关键特性：回溯。

回溯时匹配过程的基本组成部分，也是正则表达式如此强大且有表现力的根源，然而回溯会产生昂贵的计算消耗，一不小心就会失控。理解它的工作原理和如何最小化地使用它可能是编写高效正则表达式的关键所在。

当正则表达式匹配目标字符时，它从左到右逐个测试表达式的组成部分，遇到量词（*，+,?或{2,}等），正则表达式需要决定何时尝试匹配更多字符。遇到分支(如 | 操作符)，必须从可选项中选择一个尝试匹配。当正则表达式做类似决定时，有必要的话会记录其他选择，如果当前选项匹配成功，正则表达式就继续扫描表达式，如果匹配失败，就回到最后一个决策点，然后在剩余选项中选一个重复该过程，当所有选项的排列组合都尝试失败，就放弃匹配，转而移动到下一个字符重复此过程。

#### 分支与回溯

在一个起始搜索位置,从左到右开始选择分支依次匹配,若分支匹配失败,则回溯到原位置，按下一个选择分支继续匹配。

#### 贪婪和惰性的回溯

```javascript
 var str = "<p>Para 1.</p>"+
           "<p>Para 2.</p>"+
           "<div>DIV.</div>";

 /<p>.*<\/p>/i.test(str);
```

.代表能匹配除换行符的任意字符,*代表贪婪搜索,表示可以重复0~多次.

**贪婪搜索：**

这个正则表达式在一开始就匹配了所有字符,但是还要匹配<\/p>,所以从末尾开始回溯。

直到匹配到第二行的</p>，匹配成功,扫描范围为整个字符串。

**惰性搜索：**

```javascript
 /<p>.*?<\/p>/i.test(str);
```

*? 代表惰性模式,当字符串匹配.*?的时候,它会先跳过自己,让后面的&lt;\/p>先匹配,当后下后面的匹配失败后,再继续.*?的搜索。在这个例子里,正则表达式扫描完第一段,就能成功完成匹配。

如果,只有一个段落时(如str = '&lt;p>Para 1.&lt;/p>';),惰性和贪婪的扫描范围一样的,但是贪婪的效率要高，因为一开始就贪婪到了最后一个字符,然后开始回溯，而惰性,就从一开始一个一个慢慢回溯到最后,效率较低。

### 回溯失控

用[\s\S]来匹配任意字符。

```javascript
/<html>[\s\S]*?<head>[\s\S]*?<title>[\s\S]*?<\/title>[\s\S]*?<\/head>[\s\S]*?<body>[\s\S]*?</body>[\s\S]*?</html>/
```

这段正则表达式在匹配常规HTML字符运行正常，但当目标字符串缺少一个或多个必要的标签时会变得糟糕。如</html>缺失，这时字符串的最后一个[\s\S]*?会尝试扩展到字符串末尾，没找到</html>标签，正则表达式不会放弃，会尝试用倒数第二个[\s\S]*?匹配，找下一个</body>标签，直到字符串末尾，仍未找到，再继续扩展倒数第三个[\s\S]*?到字符串末尾，以此类推。

#### 解决方案:具体化

通过尽可能具体化分隔符之间的字符串匹配模式。不过这种方法匹配短字符串时运行良好，但上述例子中匹配HTML文件向前查看可能要测试上千次，有一种效率更高的解决方案，如下所述。

#### 使用预查和反向引用的模拟原子组

一些正则表达式引擎都支持一种名为“原子组”的特性（?>...）,省略号表示任意正则表达式的模式，是一组具有特殊反转性的非捕获组。一旦原子组中存在一个正则表达式，该组的任何回溯位置都会被丢弃，为HTML正则表达式的回溯问题提供了一个更好解决方案。如果把[\s\S]*?序列和它后面的HTML标签放到一个原子组中，每当所需要的HTML标签被发现一次，这次匹配就基本锁定，如果匹配失败原子组的量词不会记录回溯点，即[\s\S]*?序列已匹配部分不会被展开。


但JavaScript不支持原子组，不过可以利用预查过程中一项鲜为人知的行为模拟原子组:预查也是原子组。区别为：预查作为全局匹配的一部分，不消耗任何字符，只是检查自己包含的正则符号在当前字符串位置中是否匹配。可以通过把预查的表达式封装在捕获组中并给它添加一个反向引用的方法避免这一问题。

【

补充说明:

预查不消耗任何字符？什么意思？看代码说话：

```javascript
var s = 'adc';
console.log(/a(?=b)dc/.test(s)); // true -> 预查不消耗字符
console.log(/a(b)bc/.test(s)); // false
```

】

```javascript
(?=(pattern to make atomic))\1
```

HTML正则表达式应用此方法后的修改如下：

```javascript
/<html>(?=([\s\S]*?<head>))\1(?=([\s\S]*?<title>))\2(?=([\s\S]*?<\/title>))\3(?=([\s\S]*?<\/head>))\4(?=([\s\S]*?<body>))\5(?=([\s\S]*?<\/body>))\6[\s\S]*?<\/html>/;
```

当缺少&lt;/html>标签时，最后一个[\s\S]*?会展开到结尾，正则表达式会立刻返回匹配失败，因为没有可返回的回溯点。正则表达式每次找到一个中间的标签都会退出一个预查，在预查过程中丢弃所有回溯位置，接下来的反向引用会简单地重新匹配预查过程中发现的字符，并将它们作为实际匹配的一部分。

#### 嵌套量词与回溯失控

嵌套量词：量词出现在一个自身被重复量词修饰的组中。如： (x+)* 。


内部量词和外部量词的排列组合产生了数量巨大的分支路径，正则表达式在放弃匹配前必须尝试所有排列组合，应当注意这种情况。

一个极端的例子：在一个只包含A的字符串中用正则表达式/(A+A+)+B/，当应用到10个A组成的字符串("AAAAAAAAAA")上，正则表达式会一直经过多次回溯去找一个不存在的B。而改成/AA+B/可修复该问题，不过如果更复杂的正则表达式可能也难以避免，最好改成**/((?:(A+A+))\2)+B/**。





### 更多提升正则表达式效率的方法

- 关注如何让匹配更快失败。通常正则慢的原因是匹配失败的过程慢，而不是匹配成功的过程慢。
- 以简单、必需的字元开头。正则的起始位置应该尽可能快速排除明显不匹配的位置。
- 使用量词模式，使它们后面的字元互斥。具体化匹配模式。
- 减少分支数量，缩小分支范围。尽量使用字符集和选项组替代。
- 尽量使用非捕获组。捕获组消耗时间和内存在记录反向引用，并使它保持更新。
- 只捕获感兴趣的文本以减少后处理。即使用/" ([^"]*)"/加反向引用替代/"[^"]*"/加手动剥离引号。
- 暴露必要的字元。
- 使用合适的量词。
- 把正则表达式赋值给变量并重用它们。主要用于避免循环中的重新编译。
- 将复杂的正则表达式拆分为简单的片段。

### 何时不用正则表达式

比如：

```javascript
// 好的写法
endWithSemicolon = str.chatAt(str.length - 1) === ';';

// 不好的写法
endWithSemicolon = /;$/.test(str);
```


## 去除字符串首尾空白

该部分主要作为正则表达式优化的例子。

```javascript
if (!String.prototype.trim) {

	// trim 1 这种方法较好，简单而跨浏览器
	String.prototype.trim = function() {
		return this.replace(/^\s+/,'').replace(/^\s+$/,'');
	}
	
	// trim 2 比trim 1 慢
	String.prototype.trim = function() {
		return this.replace(/^\s+|\s+$/g,'');
	}

	// trim 3 惰性量词导致正则表达式大量额外操作（如回溯）
	String.prototype.trim = function() {
		return this.replace(/^\s*([\s\S]*?)\s*$/,'$1');
	}

	// trim 4 除非这里尾部空白比其他文字要多，否则会trim 3的方法快
	String.prototype.trim = function() {
		return this.replace(/^\s*([\s\S]*\S)?\s*$/,'$1');
	}

	// trim 5 最慢，把(\s+\S+) 改成(?:\s+\S+)会快些
	String.prototype.trim = function() {
		return this.replace(/^\s*(\S*(\s+\S+)*)\s*$/,'$1');
	}

}
```

**当不适用正则表达式时去除字符串首尾空白**

```javascript 
// trim 6 不宜处理前后大段空白
if (!String.prototype.trim) {
	String.prototype.trim = function() {
		var start = 0,
			end = this.length - 1,
			ws = '\n\r\t\f\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u200B\u2028\u2029\u202F\u205F\u3000\ufeff';

		while (ws.indexOf(this.charAt(start)) > -1) {
			start++;
		}
		while(end > start && ws.indexOf(this.charAt(end)) > -1) {
			end--;
		}

		return this.slice(start,end + 1);
	}
}
```


**混合解决方案**


```javascript
// trim 7 处理长字符串时非常快，但不适用于末尾长空白的情况
if (!String.prototype.trim) {
	String.prototype.trim = function() {
		var str = this.replace(/^\s*/,''),
			end = str.length - 1,
			ws = /\s/;
		
		while(ws.indexOf(str.charAt(end)) > -1) {
			end--;
		}
		
		return str.splice(0, end+1);
	}
}
```

