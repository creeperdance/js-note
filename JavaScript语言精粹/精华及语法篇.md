# 精华篇

JavaScript建立在一些非常优秀的想法和少数非常糟糕的想法之上。
那些优秀的想法包括**函数、弱类型、动态对象、富有表现力的对象字面量表示法**。那些糟糕的想法包括**基于全局变量的编程模型**。

JavaScript的函数是（主要）基于**词法作用域**的顶级对象。

补充说明：

**词法作用域：**

(参见《JavaScript权威指南》第5版—8.8.1词法作用域) 
JavaScript中的函数是通过词法来划分作用域的，而不是动态地划分作用域的。这意味着，它们在定义它们的作用域里运行，而不是在执行它们的作用域里运行。当定义了一个函数，当前的作用域链就保存起来，并且作为函数的内部状态的一部分。在最顶级，作用域链仅由全局对象组成，而并不和词法作用域相关。然而，当定义一个嵌套的函数时，作用域就包括外围的包含函数。这意味着嵌套的函数可以访问包含函数的所有参数和局部变量。

什么意思呢？结合下段代码

```javascript
var i = 1; 
function a() { 
	console.log(i); // undefined
	var i = 2; 
	console.log(i); // 2
} 
a(); 
```

结合上面定义来理解第一个输出为什么时undefined。因为a方法中定义了var i = 2，而JavaScript通过词法划分作用域的，即其作用域在定义时确定的，而当引擎执行到第一个console.log(i)时，会查找变量i的引用，首先从最内部的作用域，即a()函数的作用域开始查找，在这里找到了i，并使用了这个引用，而此时变量i为undefined，因而输出的i为undefined。因此上述代码和下面的代码其实是等价的：

```javascript
var i = 1; 
function a() {
	var i; 
	console.log(i); // undefined
	i = 2; 
	console.log(i); // 2
} 
a(); 
```



# 语法篇
**标识符**

**数字**

JavaScript只有一个数字类型，在内部被表示为64位的浮点数，同Java的double，它没有分离出整数类型，因此1和1.0值相同（1 === 1.0）,完全避免了短整型的溢出问题（将数据放入比它本身小的存储单元）。


NaN是一个数值，表示一个不能产生正常结果的运算结果，它不等任何值，包括自己，可用isNaN(number)测试NaN。

**字符串**

**语句**

代码块是包在一堆花括号中的一组语句，JavaScript中的代码块不会创建新的作用域。

被当做为假的值：false,null,undefined,'',0,NaN.其他都为真。

**表达式**

运算符优先级：

| 运算符        | 描述              |
| ------------- |:-------------:   |
| .  \[]  ()    | 提取属性与调用函数 |
|delete new typeof + -    |一元运算符|
| * / %    | 乘法、除法、取余 |
|+ - | 加法/连接，减法|
|>= <= > < |不等式运算符|
|=== !==| 等式运算符|
| && |逻辑与|
| || |逻辑或|
|?:|三元|


typeof运算符:

typeof运算符产生的值有:'number','string','undefined','function','object'。
如果运算数为一个数组或者null,结果为'object'。

如果第一个运算符的值为假，运算符&&产生它的第一个运算数的值，否则产生第二个运算数的值。

如果第一个运算数为真，运算符||产生它的第一个运算符的值，否则产生第二个运算数的值。


**字面量**

**函数**
